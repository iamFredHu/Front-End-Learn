# 函数高级

## 执行上下文与执行上下文栈

### 变量声明提升与函数生命提升
- 通过 var 定义（声明）的变量，在定义语句之前可以访问到
- 值：undefined

- 通过 function 声明的函数，在之前可以提前调用
- 值：函数定义（对象）
  
- 问题：变量提升和函数提升是如何产生的？

## 执行上下文
- 代码分类：全局代码和局部代码
- 全局执行上下文：（1）在执行全局代码前将window确定为全局上下文；（2）对全局数据进行预处理，var定义全局变量==>undefined，function声明的全局函数==>赋值（fun），添加为window的方法，this==>赋值（window）
- 函数执行上下文，在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
- 对局部数据进行预处理 形参变量、argument、var定义的局部变量（undefined）、function声明的函数、this

## 执行上下文栈  
1. 全局代码执行之前，JS引擎会创建一个栈来存储管理所有的执行上下文对象
2. 在全局上下文（window）确定后，将其添加到栈中（压栈）
3. 在函数执行上下文创建后，将其添加到栈中
4. 在当前函数执行完后，将栈顶的对象移除
5. 当所有代码执行完后，栈中只剩下window

## 作用域和作用域链 
- 全局作用域 函数作用域 块作用域（ES6）
- 隔离变量，不同作用域下同名变量不会有冲突

- 作用域链：多个上下级关系的作用域形成的链，它的方向是从下向上的（从内到外），查找变量就是沿着作用域链来寻找的

## 闭包
- 如何产生闭包？ 当一个嵌套的内部函数引用了嵌套的外部函数的变量（函数）时，就产生了闭包
- 条件：函数嵌套、内部函数引用了外部函数的数据（变量/函数）

## 常见的闭包
- 将函数作为另一个函数的返回值
- 将函数作为实参传递给另一个函数调用 

## 闭包的作用
- 使用函数内部的变量在函数执行完后，仍然活在内存中（延长了局部变量的生命周期）
- 让函数外部可以操作（读写）到函数内部的数据
  
问题：
1. 函数执行完后，函数内部声明的局部变量是否还存在？【一般是不存在的，存在于闭包中的变量才可能存在】
2. 在函数外部能直接访问函数内部的局部变量吗？  【不能，但是可以通过闭包来让外部操作它】

## 闭包的生命周期
- 产生：在嵌套内部函数定义时产生【不是在调用时产生，记得考虑函数提升  】
- 死亡：在嵌套的内部函数成为垃圾对象时

## 闭包的缺点
- 函数执行完后，函数内的局部变量没有及时释放，占用内存时间会边长
- 容易造成内存泄漏（占用的内存没有及时释放）
- 常见的内存泄漏：（1）意外的全局变量 （2）没有及时清理的计时器或者或调函数 （3）闭包

- 解决：少用闭包；及时释放